<link rel="import" href="../polymer/polymer.html"> <dom-module id="simpla-admin"> <template> <style>:host{position:absolute}:host([hidden]),[hidden]{display:none!important}</style> <simpla-admin-controls editable="[[_editable]]" authenticated="[[_authenticated]]" busy="{{busy}}" on-login="login" on-save="save" hidden$="[[_loginOpen]]"> </simpla-admin-controls> <simpla-login id="login" active="{{_loginOpen}}"> </simpla-login> <simpla-notify></simpla-notify> </template> <script>(function () {
'use strict';

var index = (condition, interval) => new Promise((resolve, reject) => {
	interval = typeof interval === 'number' ? interval : 20;

	const check = () => {
		Promise.resolve().then(condition).then(val => {
			if (typeof val !== 'boolean') {
				throw new TypeError('Expected condition to return a boolean');
			}

			if (val === true) {
				resolve();
			} else {
				setTimeout(check, interval);
			}
		}).catch(reject);
	};

	check();
});

var loginPrompt = {
  properties: {

    loginPrompt: {
      type: Boolean,
      observer: '_toggleLoginPromptObserver'
    }

  },

  /**
   * Observer to prompt for login if editable && !authed
   * @param {Boolean} loginPrompt Whether to prompt for login on editable
   * @return {undefined}
   */
  _toggleLoginPromptObserver: function _toggleLoginPromptObserver(loginPrompt) {
    var _this = this;

    var observers = this._simplaObservers,
        promptLogin = function promptLogin(editable) {
      var simplaLogin = _this.$['login'],
          promptAvailable = function promptAvailable() {
        return typeof simplaLogin.prompt === 'function';
      };

      index(promptAvailable, 1).then(function () {
        if (editable && !_this._authenticated) {
          simplaLogin.prompt().then(function (loggedIn) {
            Simpla.editable(loggedIn);
          });
        }
      });
    };


    if (loginPrompt) {
      promptLogin(Simpla.getState('editable'));
      observers.login = Simpla.observeState('editable', promptLogin);
    } else {
      observers.login && observers.login.unobserve();
    }
  }
};

// NOTE: Custom messages are ignored by most browsers, this is an edge perk
var UNSAVED_WARNING = 'You have unsaved changes, are you sure you want to leave?';

/**
 * Intercepts beforeunload event if Simpla buffer is dirty
 * @param  {Event} e Beforeunload event
 * @return {String}  Warning message (for browsers that support it)
 */
function warnUnsaved(e) {
  var dirtyBuffer = !!Simpla.getState('buffer');

  if (dirtyBuffer) {
    e.returnValue = UNSAVED_WARNING;
    return UNSAVED_WARNING;
  }
}

var unsavedChanges = {
  /**
   * Init unsaved changes watchdog on attach
   * @return {undefined}
   */
  attached: function attached() {
    window.addEventListener('beforeunload', warnUnsaved);
  },


  /**
   * Clean up listener on detach
   * @return {undefined}
   */
  detached: function detached() {
    window.removeEventListener('beforeunload', warnUnsaved);
  }
};

var MODIFIER = 'metaKey';
var KEY_CODES = {
  edit: 69, // E key
  save: 83 // S key
};

/**
 * Toggles Simpla editable on hotkey combination
 * @param  {Event} e  Keydown event
 * @return {undefined}
 */
function bindEditableToHotkeys(e) {
  if (e.keyCode === KEY_CODES.edit && e[MODIFIER]) {
    e.preventDefault();
    Simpla.editable(!Simpla.getState('editable'));
  }
}

/**
 * Executes Simpla.save on hotkey combination
 * @param  {Event} e  Keydown event
 * @return {undefined}
 */
function bindSaveToHotkeys(e) {
  if (e.keyCode === KEY_CODES.save && e[MODIFIER]) {
    e.preventDefault();
    document.querySelector('simpla-admin').save();
  }
}

var hotkeys = {
  properties: {

    hotkeys: Boolean

  },

  observers: ['_updateEditableListener(_authenticated, hotkeys)', '_updateSaveListener(_editable, hotkeys)'],

  /**
   * Adds or removes editable hotkey listener based on authenticated state
   * @param  {Boolean} authenticated Current value of authenticated prop
   * @return {undefined}
   */
  _updateEditableListener: function _updateEditableListener(authenticated, hotkeys) {
    if (authenticated && hotkeys) {
      document.addEventListener('keydown', bindEditableToHotkeys);
    } else {
      document.removeEventListener('keydown', bindEditableToHotkeys);
    }
  },


  /**
   * Adds or removes save hotkey listener based on editable state
   * @param  {Boolean} authenticated Current value of authenticated prop
   * @return {undefined}
   */
  _updateSaveListener: function _updateSaveListener(editable, hotkeys) {
    if (editable && hotkeys) {
      document.addEventListener('keydown', bindSaveToHotkeys);
    } else {
      document.removeEventListener('keydown', bindSaveToHotkeys);
    }
  },


  /**
   * Clean up listeners on detach
   * @return {undefined}
   */
  detached: function detached() {
    document.removeEventListener('keydown', bindEditableToHotkeys);
    document.removeEventListener('keydown', bindSaveToHotkeys);
  }
};

function attachWhenReady(element) {
  var attachIfReady = function attachIfReady() {
    if (document.body) {
      document.body.appendChild(element);
      document.removeEventListener('readystatechange', attachIfReady);
      return true;
    }

    return false;
  };

  attachIfReady() || document.addEventListener('readystatechange', attachIfReady);
}

/**
 * Attaches simpla-admin to the users document
 * @param  {Boolean} shouldAttach Whether simpla-admin should be attached
 * @return {undefined}
 */
function conditionallyAttach(shouldAttach) {
  var alreadyAttached = document.querySelector('simpla-admin'),
      adminElement = void 0;

  if (shouldAttach && !alreadyAttached) {
    adminElement = document.createElement('simpla-admin');
    attachWhenReady(adminElement);
  }
}

/**
 * Self attach simpla-admin when editable or authenticated
 * @return {undefined}
 */
var SelfAttach = {
  _simplaObservers: [],

  observe: function observe() {
    var _this = this;

    index(function () {
      return !!window.Simpla;
    }, 1).then(function () {
      var _Simpla$getState = Simpla.getState(),
          editable = _Simpla$getState.editable,
          authenticated = _Simpla$getState.authenticated,
          shouldAttach = editable || authenticated;

      conditionallyAttach(shouldAttach);

      _this._simplaObservers = [Simpla.observeState('authenticated', conditionallyAttach), Simpla.observeState('editable', conditionallyAttach)];
    });
  },
  unobserve: function unobserve() {
    this._simplaObservers.forEach(function (observer) {
      return observer.unobserve();
    });
    this._simplaObservers = [];
  }
};

var HASH = '#edit';

function hashToEditable() {
  var isEdit = window.location.hash === HASH;

  Simpla.editable(isEdit);
}

function editableToHash(editable) {
  window.location.hash = editable ? HASH : '';
}

var HashTracking = {
  _simplaObserver: null,

  _tracking: false,

  track: function track() {
    var _this = this;

    index(function () {
      return !!window.Simpla;
    }, 1).then(function () {
      hashToEditable();

      if (_this._tracking) {
        return;
      }

      window.addEventListener('hashchange', hashToEditable);
      editableToHash(Simpla.getState('editable'));

      _this._simplaObserver = Simpla.observeState('editable', editableToHash);
      _this._tracking = true;
    });
  },
  untrack: function untrack() {
    if (this._tracking) {
      window.removeEventListener('hashchange', hashToEditable);
      this._simplaObserver && this._simplaObserver.unobserve();
      this._simplaObserver = null;
      this._tracking = false;
    }
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var ADMIN_ELEMENTS = ['simpla-admin'];
var EVENTS_TO_BLOCK = ['click', 'ontouchend'];

var observer = void 0;
var isolatedElements = void 0;

isolatedElements = function () {
  var elementList = void 0;

  if (_typeof(window.Map) !== undefined) {
    return new Map();
  }

  elementList = [];

  return {
    has: function has(element) {
      return elementList.indexOf(element) !== -1;
    },
    set: function set(element, value) {
      var index = elementList.indexOf(element);

      if (index === -1) {
        elementList.push(element);
      }
    },
    delete: function _delete(element) {
      var index = elementList.indexOf(element);

      if (index !== -1) {
        elementList.splice(index, 1);
      }
    },
    forEach: function forEach(callback) {
      elementList.forEach(function (element, i, thisArg) {
        return callback.call(thisArg, 0, element, i);
      });
    }
  };
}();

/**
 * Stops the given event from propagating, and also stops the event if event did
 *  not originate from an input. This means that clicks originating in forms e.g.
 *  file inputs will still work
 * @param  {Event} event Event to cancel
 * @return {undefined}
 */
function stopAndPreventUnimportant(event) {
  if (!event.path[0].localName || event.path[0].localName !== 'input') {
    event.preventDefault();
  }

  event.stopPropagation();
}

/**
 * Check if given element name is Simpla name
 * @param  {string}  name Name to check
 * @return {Boolean}      True if name is name of a simpla element
 */
function isSimplaName(name) {
  var prefixed = function prefixed(str) {
    return str.indexOf('simpla-') === 0;
  };

  return name && prefixed(name);
}

/**
 * Check if the given element is a Simpla Element
 * @param  {Node}  node   Node to check
 * @return {Boolean}      True if node is a Simpla Element
 */
function isSimplaElement(node) {
  if (isSimplaName(node.localName)) {
    return true;
  }

  return node.getAttribute && isSimplaName(node.getAttribute('is'));
}

/**
 * Checks if the given node is an editable element. Editable means the element
 *  is a Simpla Element and it is not a special ignored element e.g. simpla-admin
 * @param  {Node}   node  Node to check if it's an editable element
 * @return {Boolean}      True if editable element, false otherwise
 */
function isEditableElement(node) {
  var ignored = function ignored(name) {
    return ADMIN_ELEMENTS.includes(name);
  },
      isEditableName = function isEditableName(name) {
    return isSimplaName(name) && !ignored(name);
  };

  if (isEditableName(node.localName)) {
    return true;
  }

  return isEditableName(node.getAttribute && node.getAttribute('is'));
}

/**
 * Get all editable elements in the given list.
 * @param  {(NodeList|Node[])} list List of nodes to check
 * @return {HTMLElement[]}          Array of editable elements
 */
function editableElementsIn(list) {
  return Array.prototype.filter.call(list, isEditableElement);
}

/**
 * Get all simpla elements in the given list.
 * @param  {(NodeList|Node[])} list List of nodes to check
 * @return {HTMLElement[]}          Array of simpla elements
 */
function simplaElementsIn(list) {
  return Array.prototype.filter.call(list, isSimplaElement);
}

/**
 * Gets all elements that are currently stored and have their click events blocked
 * @param  {(NodeList|Node[])} list NodeList or Array of nodes to check
 * @return {HTMLElement[]}          Array of elements that have click listeners blocked
 */
function blockedElementsIn(list) {
  return Array.prototype.filter.call(list, function (element) {
    return isolatedElements.has(element);
  });
}

/**
 * Set pointer events property on given element to given state
 * @param  {HTMLElement}  element Element to set pointer events on
 * @param  {string=}      state   State of pointer events
 * @return {undefined}
 */
function setPointerEventsOn(element) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  element.style.pointerEvents = state;
}

/**
 * Explicitly enable pointer events by setting them to 'auto'
 * @param  {HTMLElement} element Element to set pointer events on
 * @return {undefined}
 */
function enablePointerEventsOn(element) {
  setPointerEventsOn(element, 'auto');
}

/**
 * Explicitly disable pointer events on given element by setting to 'none'
 * @param  {HTMLElement} element HTML to set disable pointer events on
 * @return {undefined}
 */
function disablePointerEventsOn(element) {
  setPointerEventsOn(element, 'none');
}

/**
 * Reset pointer events by setting inline value to ''
 * @param  {HTMLElement} element Element to reset pointer events on
 * @return {undefined}
 */
function resetPointerEventsOn(element) {
  setPointerEventsOn(element, '');
}

/**
 * Cancel click events on the given element
 * @param  {HTMLElement} element Element to cancel click events on
 * @return {undefined}
 */
function cancelClicksAndAllowPointer(element) {
  isolatedElements.set(element, 0);
  enablePointerEventsOn(element);
  EVENTS_TO_BLOCK.forEach(function (event) {
    element.addEventListener(event, stopAndPreventUnimportant);
  });
}

/**
 * Restore click events on the given element
 * @param  {HTMLElement} element Element to restore click events on
 * @return {undefined}
 */
function restoreClicksAndResetPointer(element) {
  isolatedElements.delete(element);
  resetPointerEventsOn(element);
  EVENTS_TO_BLOCK.forEach(function (event) {
    element.removeEventListener(event, stopAndPreventUnimportant);
  });
}

/**
 * Core observer which watches elements to block click events / restore click
 *  events on
 * @type {MutationObserver}
 */
observer = new MutationObserver(function (mutations) {
  mutations.forEach(function (mutation) {
    editableElementsIn(mutation.addedNodes).forEach(cancelClicksAndAllowPointer);

    simplaElementsIn(mutation.addedNodes).forEach(enablePointerEventsOn);

    blockedElementsIn(mutation.removedNodes).forEach(restoreClicksAndResetPointer);
  });
});

var PointerEvents = {
  /**
   * Enable pointerEvents on non-Simpla elements
   * @return {undefined}
   */
  enable: function enable() {
    isolatedElements.forEach(function (_, element) {
      return restoreClicksAndResetPointer(element);
    });
    observer.disconnect();
    resetPointerEventsOn(document.body);
  },


  /**
   * Disable pointerEvents on non-Simpla elements
   * @return {undefined}
   */
  disable: function disable() {
    var allElements = document.querySelectorAll('*');
    editableElementsIn(allElements).forEach(cancelClicksAndAllowPointer);

    simplaElementsIn(allElements).forEach(enablePointerEventsOn);

    disablePointerEventsOn(document.body);
    observer.observe(document.body, { childList: true, subtree: true });
  }
};

// Behaviors
// Utils
var LAZYLOAD_DEPENDENCIES = ['../simpla-login/simpla-login.html', '../simpla-notify/simpla-notify.html', 'simpla-admin-controls.html'];
var NOTIFICATIONS = {
  saved: 'changes saved',
  saveFailed: 'something went wrong, try again?'
};
var DEFAULT_CONFIG = {
  hashTracking: true,
  loginPrompt: true,
  hotkeys: true,
  protectEditing: true
};

// Globals
window.SimplaAdmin = _extends({}, DEFAULT_CONFIG, window.SimplaAdmin);
SelfAttach.observe();

if (window.SimplaAdmin.hashTracking) {
  HashTracking.track();
}

// Component

var SimplaAdmin = function () {
  function SimplaAdmin() {
    classCallCheck(this, SimplaAdmin);
  }

  createClass(SimplaAdmin, [{
    key: 'beforeRegister',
    value: function beforeRegister() {
      this.is = 'simpla-admin';

      this.properties = {

        /**
         * Whether to bind editable to #edit
         * @type {Boolean}
         */
        hashTracking: {
          type: Boolean,
          observer: '_updateHashTracking'
        },

        /**
         * Whether to disable pointer events on non-Simpla elements or not
         * @type {Boolean}
         */
        protectEditing: Boolean,

        /**
         * Hide admin when inactive
         * @type {Boolean}
         */
        hidden: {
          type: Boolean,
          reflectToAttribute: true
        },

        busy: {
          type: Boolean,
          value: false
        },

        /**
         * Simpla editable state
         * @type {Boolean}
         */
        _editable: Boolean,

        /**
         * Simpla authenticated state
         * @type {[type]}
         */
        _authenticated: Boolean,

        /**
         * Whether lazyload deps have been imported
         * @type {Boolean}
         */
        _dependenciesImported: Boolean,

        /**
         * Whether login modal is currently open
         * @type {Boolean}
         */
        _loginOpen: Boolean,

        /**
         * Store of Simpla observers
         * @type {Object}
         */
        _simplaObservers: {
          type: Object,
          value: {}
        }

      };

      this.observers = ['_toggleHidden(_editable, _authenticated)', '_disableEditable(busy)', '_updatePointerEvents(protectEditing, _editable)'];
    }
  }, {
    key: 'ready',


    /**
     * Attach singleton to window on created
     * @return {[type]} [description]
     */
    value: function ready() {
      _extends(this, window.SimplaAdmin);
      window.SimplaAdmin = this;
    }

    /**
     * Init simpla-admin
     * @return {undefined}
     */

  }, {
    key: 'attached',
    value: function attached() {
      this._importDependencies();
      this._syncEditableAndAuthenticated();
    }

    /**
     * Clean up observers on detach
     * @return {undefined}
     */

  }, {
    key: 'detached',
    value: function detached() {
      var _this = this;

      Object.keys(this._simplaObservers).forEach(function (observer) {
        _this._simplaObservers[observer].unobserve();
      });
      this._simplaObservers = {};

      HashTracking.untrack();
      SelfAttach.unobserve();
    }

    /**
     * Disable editable when admin is busy
     * @param  {Boolean} busy Whether admin is busy
     * @return {undefined}
     */

  }, {
    key: '_disableEditable',
    value: function _disableEditable(busy) {
      if (busy && Simpla.getState('editable')) {
        HashTracking.untrack();
        Simpla.editable(false);
        this.__busyDisabled = true;
      } else if (!busy && this.__busyDisabled) {
        Simpla.editable(true);
        HashTracking.track();
        this.__busyDisabled = false;
      }
    }

    /**
     * Utility method to open simpla-login
     * @return {undefined}
     */

  }, {
    key: 'login',
    value: function login() {
      this.$['login'].open();
    }

    /**
     * Save content with Simpla
     * @return {undefined}
     */

  }, {
    key: 'save',
    value: function save() {
      var _this2 = this;

      var success = function success() {
        _this2.busy = false;
        _this2.fire('simpla-notification', {
          text: NOTIFICATIONS.saved
        });
      },
          failed = function failed() {
        _this2.busy = false;
        _this2.fire('simpla-notification', {
          text: NOTIFICATIONS.saveFailed
        });
      };

      this.busy = true;

      Simpla.save().then(success).catch(failed);
    }

    /**
     * Observes Simpla state to hide admin when inactive
     * @param  {Boolean} editable      Current value of the editable prop
     * @param  {Boolean} authenticated Current value of the authenticated prop
     * @return {undefined}
     */

  }, {
    key: '_toggleHidden',
    value: function _toggleHidden(editable, authenticated) {
      this.hidden = !editable && !authenticated;
    }

    /**
     * Update hashtracker when hashTracking prop changes
     * @param  {Boolean} hashTracking Whether to bind editable to #edit
     * @return {undefined}
     */

  }, {
    key: '_updateHashTracking',
    value: function _updateHashTracking(hashTracking) {
      if (hashTracking) {
        HashTracking.track();
      } else {
        HashTracking.untrack();
      }
    }

    /**
     * Update pointer events based on protectEditing option and editable state
     * @param   {Boolean} protectEditing  Whether should disable clicks in edit mode
     * @param   {Boolean} editable        Whether Simpla is in edit mode
     * @return  {undefined}
     */

  }, {
    key: '_updatePointerEvents',
    value: function _updatePointerEvents(protectEditing, editable) {
      if (protectEditing && editable) {
        PointerEvents.disable();
      } else {
        PointerEvents.enable();
      }
    }

    /**
     * Keeps editable and authenticated properties in sync with Simpla state
     * @return {undefined}
     */

  }, {
    key: '_syncEditableAndAuthenticated',
    value: function _syncEditableAndAuthenticated() {
      var _this3 = this;

      var _Simpla$getState = Simpla.getState(),
          editable = _Simpla$getState.editable,
          authenticated = _Simpla$getState.authenticated,
          updateEditable = function updateEditable(editable) {
        return _this3._editable = editable;
      },
          updateAuthenticated = function updateAuthenticated(authenticated) {
        return _this3._authenticated = authenticated;
      };

      // Set initial values


      updateEditable(editable);
      updateAuthenticated(authenticated);

      // Observe future changes
      this._simplaObservers.editable = Simpla.observeState('editable', updateEditable);
      this._simplaObservers.authenticated = Simpla.observeState('authenticated', updateAuthenticated);
    }

    /**
     * Lazily import deps on attach
     * @return {undefined}
     */

  }, {
    key: '_importDependencies',
    value: function _importDependencies() {
      var _this4 = this;

      LAZYLOAD_DEPENDENCIES.forEach(function (dependency) {
        _this4.importHref(_this4.resolveUrl(dependency));
      });
    }
  }, {
    key: 'behaviors',
    get: function get() {
      return [loginPrompt, hotkeys, unsavedChanges];
    }
  }]);
  return SimplaAdmin;
}();


Polymer(SimplaAdmin);

}()); </script> </dom-module> 